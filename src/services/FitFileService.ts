import { supabase } from '@/lib/supabase';
import { StravaActivity, FitFileData, ActivityStream } from '@/types/activity';
import { Logger } from './Logger';

class FitFileService {
  private logger = new Logger('FitFileService');

  /**
   * Download .fit file from Strava for a specific activity
   */
  async downloadFitFile(activityId: number, accessToken: string): Promise<ArrayBuffer | null> {
    try {
      this.logger.info(`Downloading .fit file for activity ${activityId}`);
      
      const response = await fetch(`https://www.strava.com/api/v3/activities/${activityId}/export_gpx`, {
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Accept': 'application/fit'
        }
      });

      if (!response.ok) {
        this.logger.error(`Failed to download .fit file: ${response.status} ${response.statusText}`);
        return null;
      }

      const fitData = await response.arrayBuffer();
      this.logger.info(`Downloaded .fit file: ${fitData.byteLength} bytes`);
      
      return fitData;
    } catch (error) {
      this.logger.error('Error downloading .fit file:', error);
      return null;
    }
  }

  /**
   * Get activity streams from Strava API (fallback if .fit not available)
   */
  async getActivityStreams(activityId: number, accessToken: string) {
    try {
      this.logger.info(`Getting activity streams for ${activityId}`);
      
      const streamTypes = [
        'time', 'distance', 'latlng', 'altitude', 'velocity_smooth',
        'heartrate', 'cadence', 'watts', 'temp', 'moving', 'grade_smooth'
      ].join(',');

      const response = await fetch(
        `https://www.strava.com/api/v3/activities/${activityId}/streams?keys=${streamTypes}&key_by_type=true`,
        {
          headers: {
            'Authorization': `Bearer ${accessToken}`,
          }
        }
      );

      if (!response.ok) {
        this.logger.error(`Failed to get streams: ${response.status}`);
        return null;
      }

      const streams = await response.json();
      this.logger.info(`Retrieved ${Object.keys(streams).length} stream types`);
      
      return streams;
    } catch (error) {
      this.logger.error('Error getting activity streams:', error);
      return null;
    }
  }

  /**
   * Parse .fit file data (simplified - in production would use proper FIT SDK)
   * For now, we'll use Strava streams as the data source
   */
  parseFitFile(fitData: ArrayBuffer): FitFileData | null {
    try {
      this.logger.info('Parsing .fit file data');
      
      // This is a simplified implementation
      // In production, you would use the FIT SDK from Garmin/ANT+
      // For now, we'll return null and rely on Strava streams
      
      this.logger.warn('.fit file parsing not implemented - using Strava streams instead');
      return null;
    } catch (error) {
      this.logger.error('Error parsing .fit file:', error);
      return null;
    }
  }

  /**
   * Convert Strava streams to our ActivityStream format
   */
  convertStreamsToActivityStreams(
    streams: any, 
    activityId: string, 
    userId: string
  ): ActivityStream[] {
    try {
      this.logger.info('Converting Strava streams to activity streams');
      
      const timeStream = streams.time?.data || [];
      const powerStream = streams.watts?.data || [];
      const hrStream = streams.heartrate?.data || [];
      const cadenceStream = streams.cadence?.data || [];
      const speedStream = streams.velocity_smooth?.data || [];
      const distanceStream = streams.distance?.data || [];
      const altitudeStream = streams.altitude?.data || [];
      const gradeStream = streams.grade_smooth?.data || [];
      const tempStream = streams.temp?.data || [];
      const latlngStream = streams.latlng?.data || [];

      const activityStreams: ActivityStream[] = [];
      const maxLength = Math.max(
        timeStream.length,
        powerStream.length,
        hrStream.length,
        cadenceStream.length
      );

      for (let i = 0; i < maxLength; i++) {
        const stream: ActivityStream = {
          id: '', // Will be generated by database
          activity_id: activityId,
          user_id: userId,
          timestamp_offset: timeStream[i] || i,
          power: powerStream[i] || undefined,
          heart_rate: hrStream[i] || undefined,
          cadence: cadenceStream[i] || undefined,
          speed: speedStream[i] || undefined,
          distance: distanceStream[i] || undefined,
          altitude: altitudeStream[i] || undefined,
          grade: gradeStream[i] || undefined,
          temperature: tempStream[i] || undefined,
          latitude: latlngStream[i] ? latlngStream[i][0] : undefined,
          longitude: latlngStream[i] ? latlngStream[i][1] : undefined,
          created_at: new Date().toISOString()
        };

        // Calculate rolling averages for power
        if (stream.power) {
          stream.power_3s = this.calculateRollingAverage(powerStream, i, 3);
          stream.power_30s = this.calculateRollingAverage(powerStream, i, 30);
        }

        activityStreams.push(stream);
      }

      this.logger.info(`Converted ${activityStreams.length} stream points`);
      return activityStreams;
    } catch (error) {
      this.logger.error('Error converting streams:', error);
      return [];
    }
  }

  /**
   * Calculate rolling average for power data
   */
  private calculateRollingAverage(data: number[], currentIndex: number, windowSize: number): number | undefined {
    if (!data[currentIndex]) return undefined;
    
    const start = Math.max(0, currentIndex - Math.floor(windowSize / 2));
    const end = Math.min(data.length, currentIndex + Math.ceil(windowSize / 2));
    
    const window = data.slice(start, end).filter(val => val != null && val > 0);
    
    if (window.length === 0) return undefined;
    
    return Math.round(window.reduce((sum, val) => sum + val, 0) / window.length);
  }

  /**
   * Store activity streams in database
   */
  async storeActivityStreams(streams: ActivityStream[]): Promise<boolean> {
    try {
      this.logger.info(`Storing ${streams.length} activity streams`);
      
      if (streams.length === 0) {
        this.logger.warn('No streams to store');
        return true;
      }

      // Insert in batches to avoid timeout
      const batchSize = 1000;
      let totalInserted = 0;
      
      for (let i = 0; i < streams.length; i += batchSize) {
        const batch = streams.slice(i, i + batchSize);
        
        const { error } = await supabase
          .from('activity_streams')
          .insert(batch);

        if (error) {
          this.logger.error(`Error inserting batch ${i}-${i + batchSize}:`, error);
          return false;
        }
        
        totalInserted += batch.length;
        this.logger.info(`Inserted batch: ${totalInserted}/${streams.length}`);
      }

      this.logger.info(`Successfully stored ${totalInserted} activity streams`);
      return true;
    } catch (error) {
      this.logger.error('Error storing activity streams:', error);
      return false;
    }
  }

  /**
   * Get stored activity streams from database
   */
  async getStoredStreams(activityId: string): Promise<ActivityStream[]> {
    try {
      const { data, error } = await supabase
        .from('activity_streams')
        .select('*')
        .eq('activity_id', activityId)
        .order('timestamp_offset', { ascending: true });

      if (error) {
        this.logger.error('Error fetching stored streams:', error);
        return [];
      }

      return data || [];
    } catch (error) {
      this.logger.error('Error getting stored streams:', error);
      return [];
    }
  }

  /**
   * Check if activity has streams data
   */
  async hasStreamData(activityId: string): Promise<boolean> {
    try {
      const { count, error } = await supabase
        .from('activity_streams')
        .select('id', { count: 'exact', head: true })
        .eq('activity_id', activityId);

      if (error) {
        this.logger.error('Error checking stream data:', error);
        return false;
      }

      return (count || 0) > 0;
    } catch (error) {
      this.logger.error('Error checking stream data:', error);
      return false;
    }
  }

  /**
   * Process activity for .fit file download and stream processing
   */
  async processActivity(
    activity: StravaActivity, 
    activityId: string, 
    userId: string, 
    accessToken: string
  ): Promise<boolean> {
    try {
      this.logger.info(`Processing activity ${activity.id} for user ${userId}`);

      // Check if already processed
      const hasStreams = await this.hasStreamData(activityId);
      if (hasStreams) {
        this.logger.info('Activity already has stream data, skipping');
        return true;
      }

      // Try to download .fit file first
      let streams = null;
      const fitData = await this.downloadFitFile(activity.id, accessToken);
      
      if (fitData) {
        // Parse .fit file
        const fitParsed = this.parseFitFile(fitData);
        if (fitParsed) {
          streams = fitParsed.streams;
          this.logger.info('Using .fit file data');
        }
      }

      // Fallback to Strava streams API
      if (!streams) {
        this.logger.info('Falling back to Strava streams API');
        const stravaStreams = await this.getActivityStreams(activity.id, accessToken);
        
        if (stravaStreams) {
          const activityStreams = this.convertStreamsToActivityStreams(
            stravaStreams, 
            activityId, 
            userId
          );
          streams = activityStreams;
        }
      }

      // Store streams in database
      if (streams && streams.length > 0) {
        const success = await this.storeActivityStreams(streams);
        if (success) {
          this.logger.info('Successfully processed and stored activity streams');
          return true;
        }
      }

      this.logger.warn('No stream data available for activity');
      return false;
    } catch (error) {
      this.logger.error('Error processing activity:', error);
      return false;
    }
  }
}

export default new FitFileService();